<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Java Singleton | liyingjie&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Singleton 单例模式单例模式是指只允许存在一个实例的类，通常的做法会将类的构造器设为私有，这样可以阻止在类外部对它进行实例化。既然无法在类外部进行实例化，单例类会提供一个公有的static方法来获取这个类的唯一实例。
简单粗暴的写法根据单例类的定义，单例类需要满足以下两个要求：

构造器私有
提供公有静态方法来获取类唯一的实例

一个简单粗暴的实现方法如下：123456789public">
<meta property="og:type" content="article">
<meta property="og:title" content="Java Singleton">
<meta property="og:url" content="http://liyingjie.me/2015/07/09/Java-Singleton/index.html">
<meta property="og:site_name" content="liyingjie's blog">
<meta property="og:description" content="Singleton 单例模式单例模式是指只允许存在一个实例的类，通常的做法会将类的构造器设为私有，这样可以阻止在类外部对它进行实例化。既然无法在类外部进行实例化，单例类会提供一个公有的static方法来获取这个类的唯一实例。
简单粗暴的写法根据单例类的定义，单例类需要满足以下两个要求：

构造器私有
提供公有静态方法来获取类唯一的实例

一个简单粗暴的实现方法如下：123456789public">
<meta property="og:image" content="http://t0.gfsstp.com/images?q=tbn:ANd9GcTCF7bOJAAfUYwm6q96BZ3vdr6BSRy2LTiVt7AN6YAIvq_J2lka">
<meta property="og:updated_time" content="2015-07-10T13:08:40.907Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java Singleton">
<meta name="twitter:description" content="Singleton 单例模式单例模式是指只允许存在一个实例的类，通常的做法会将类的构造器设为私有，这样可以阻止在类外部对它进行实例化。既然无法在类外部进行实例化，单例类会提供一个公有的static方法来获取这个类的唯一实例。
简单粗暴的写法根据单例类的定义，单例类需要满足以下两个要求：

构造器私有
提供公有静态方法来获取类唯一的实例

一个简单粗暴的实现方法如下：123456789public">
  
  
    <link rel="icon" href="/favicon.png">
  

  <link rel="stylesheet" href="/css/style.css" type="text/css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  
  
    <link rel="stylesheet" href="/scrollLoading/style.css" type="text/css">
  
  


  
    <style type="text/css">
      .logo { background-image:url(/images/logo-header.png); }
    </style>
  

  
    <link href='//fonts.useso.com/css?family=Titillium+Web:300,400,600' rel='stylesheet' type='text/css'>
    <link href="//fonts.useso.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

</head>

<body>
  <div id="wrap">
    <header id="header">
  <div id="header-outer" class="outer">
    <div class="container">
      <div class="container-inner">
        <div id="header-title">
          <h1 class="logo-wrap">
            <a href="/" class="logo"></a>
          </h1>
          
            <h2 class="subtitle-wrap">
              <p class="subtitle">liyingjie&#39;s blog</p>
            </h2>
          
        </div>
        <div id="header-inner" class="nav-container">
          <a id="main-nav-toggle" class="nav-icon"></a>
          <div class="nav-container-inner">
            <ul id="main-nav">
              
                <li class="main-nav-list-item" ><a class="main-nav-list-link" href="/">Home | 主页</a></li>
              
                <li class="main-nav-list-item" ><a class="main-nav-list-link" href="/archives/archives.html">Archives | 归档</a></li>
              
                <li class="main-nav-list-item" ><a class="main-nav-list-link" href="/categories/index.html">Categories | 分类</a></li>
              
                <li class="main-nav-list-item" ><a class="main-nav-list-link" href="/tags/index.html">Tags | 标签</a></li>
              
                <li class="main-nav-list-item" ><a class="main-nav-list-link" href="/about/index.html">About | 关于</a></li>
              
            </ul>
            <nav id="sub-nav">
              <div id="search-form-wrap">
                <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><input type="hidden" name="sitesearch" value="http://liyingjie.me"></form>
              </div>
            </nav>
          </div>
        </div>
      </div>
    </div>
  </div>
</header>
    <div class="container">
      <div class="main-body container-inner">
        <div class="main-body-inner">
          <section id="main">
            <div class="main-body-header">

              <h1 class="header"><a class="page-title-link" href="/categories/Java/">Java</a></h1>
            </div>
            <div class="main-body-content">
              
  <article id="post-Java-Singleton" class="article article-single article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
      <!--  -->
      
        <header class="article-header">
          
  
    <h1 class="article-title" itemprop="name">
      Java Singleton
    </h1>
  

        </header>
      
      <p class="article-byline">
        <a href="/2015/07/09/Java-Singleton/" class="article-date">
  <time datetime="2015-07-09T14:15:39.000Z" itemprop="datePublished">2015-07-09</time>
</a>
      </p>
      <div class="article-entry" itemprop="articleBody">
        <p><img src="http://t0.gfsstp.com/images?q=tbn:ANd9GcTCF7bOJAAfUYwm6q96BZ3vdr6BSRy2LTiVt7AN6YAIvq_J2lka" alt="Java Singleton"></p>
<h1 id="Singleton_单例模式">Singleton 单例模式</h1><p>单例模式是指只允许存在一个实例的类，通常的做法会将类的构造器设为私有，这样可以阻止在类外部对它进行实例化。既然无法在类外部进行实例化，单例类会提供一个公有的static方法来获取这个类的唯一实例。</p>
<h1 id="简单粗暴的写法">简单粗暴的写法</h1><p>根据单例类的定义，单例类需要满足以下两个要求：</p>
<ol>
<li>构造器私有</li>
<li>提供公有静态方法来获取类唯一的实例</li>
</ol>
<p>一个简单粗暴的实现方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> INSTANCE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方法直接使用static final 初始化类一个的实例，可以保证类加载后通过公有静态方法获取的者阳同一个唯一的实例，很简单，但也很实用，对于那些程序运行前就必須做一些初始化工作的单例类，是最简单快捷的实现。</p>
<h1 id="单例延迟(懒)加载">单例延迟(懒)加载</h1><p>以上单例的实现方法有一个缺点，就是在类加载的时候类的实例就被初始化了，即使没有调用单例类的静态方法getInstance()，类的唯一实例也随着类加载而被初始化了。这可能会引起一些问题，导致类实例初始化的时机将不再受程序所控制，而是取决于类加载的时机。如果程序中有很多个单例类或者单例类在初始化的时候很耗时且占用很大的内存，那么程序启动的时候将非常缓慢且占用过多不必要的内存。<br>对于那些不需要在程序启动时就使用的单例类实例，最好的做法就是在调用单例类的getInstance()方法时再实例化类的唯一实例，这样的实现即是单例延迟加载，以称懒加载(lazy loading)。</p>
<h1 id="懒加载错误的实现方式">懒加载错误的实现方式</h1><p>实现懒加载需要做的是在调用单例类getInstance()静态方法时再初始化单例类的实例，如果已经实例化过了，就直接返回即可。看上去很简单，最容易想到的是下面这种做法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">			INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> INSTANCE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上实现看上去没有问题，调用getInstance()时加上个判断，类的唯一实例INSTANCE为null则实例化一个。问题是上面的过程忽略了多线程调用时的情况，如果有多个线程同时调用getInstance()，这多个线程都同时发现还没有单例类实例化过，于是都再次执行了<code>INSTANCE = new Singleton();</code>，最终导致该单例类被实例化了多次。</p>
<h3 id="糟糕的解决方案">糟糕的解决方案</h3><p>上面的实现方式没有考虑多线程调用，很容易一拍脑袋就写出下面的做法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">		INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>加个synchronized阻止多线程同时调用这下解决了吧。没那么简单！这种方法之所以糟糕，在于其简单粗暴的头痛医头脚痛医脚的就直接将getInstance()限制成线程独占执行，然而对于getInstance()方法，只有在第一次实例化的时候需要保证没有多个线程在同时执行初始化操作，在实例化完之后，这个独占锁就成了累赘，获得锁和去锁的过程不仅大大降低了获取实例方法的性能，还同时阻止了多个线程同时的调用。</p>
<h1 id="懒加载正确的多线程解决方案">懒加载正确的多线程解决方案</h1><p>下面这种实现方式正确的使用多线程思路来解决以上懒加载出现的问题，既可以保证类实例的唯一性，又不影响多线程的调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123; 		<span class="comment">// Single Checked</span></span><br><span class="line">			<span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">				<span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123; <span class="comment">// Double Checked</span></span><br><span class="line">					INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> INSTANCE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上述的实现中，当调用getSingleton()时首先检查是否已实例化过，如果已经实例化了就直接返回唯一实例，这一过程并未加锁，这么做可以保证在实例化之后多线程调用时不存在互斥访问导致访问性能低下的问题。当发现类还没有实例化之后，需要对单例类唯一的实例进行初始化，这个时候就有必要对这一过程加上锁了，这样可以防止多个线程进行实例化。同时最为关键的是，进行上锁代码之后，再一次对INSTANCE 变量进行了一次判断，如果不为空才初始化。这一步很重要，因为如果不加上这个判断，则当两个或多个线程执行到synchronized上锁的代码时，第一个线程获得了锁进去做了实例化操作，而其它线程则被阻塞住了，当第一个线程实例化结束归还锁时，其它阻塞的线程获得锁，再次进入synchronized上锁的代码，这个时候如果不判断INSTANCE是否为空，则又会对其实例化一次。上面的过程被称为双重检验锁(double checked locking pattern)，代码里进行了两次检查，一次是在同步块外，一次是在同步块内。<br>然而以上过程仍不能保证类只实例化一次，问题在<figure class="highlight"><figcaption><span>= new Singleton();```这句代码上，由于JVM 存在指令重排序，有可能INSTANCE在还未初始化完时就已经被指向了分配的内存空间，导致其它线程在第一个线程还未初始化结束时进入到了同步代码区内，再次对类进行了一次实例化。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#35299;&#20915;&#26041;&#27861;&#26159;&#23558;INSTANCE&#22768;&#26126;&#20026;volatile&#65292;&#36825;&#26679;&#21487;&#20197;&#21578;&#35785;JVM&#65292;&#19981;&#35201;&#22312;INSTANCE&#36827;&#34892;&#21021;&#22987;&#21270;&#26102;&#36827;&#34892;&#37325;&#25490;&#24207;&#65292;&#38450;&#27490;INSTANCE&#22312;&#36824;&#26410;&#21021;&#22987;&#21270;&#32467;&#26463;&#20043;&#21069;&#23601;&#24050;&#32463;&#20026;&#38750;null&#12290;&#10;&#10;# &#38745;&#24577;&#20869;&#37096;&#31867;&#23454;&#29616;&#25042;&#21152;&#36733;&#10;&#21487;&#20197;&#30475;&#20986;&#20197;&#22810;&#32447;&#31243;&#24605;&#36335;&#26469;&#35299;&#20915;&#21333;&#20363;&#38382;&#39064;&#23454;&#22312;&#26159;&#36807;&#20110;&#22797;&#26434;&#65292;&#24456;&#23481;&#26131;&#23601;&#20250;&#22240;&#30095;&#24573;&#20889;&#38169;&#12290;&#21487;&#20197;&#21033;&#29992;&#38745;&#24577;&#20869;&#37096;&#31867;&#26469;&#23454;&#29616;&#21333;&#20363;&#31867;&#25042;&#21152;&#36733;&#65306;&#10;```java&#10;public class Singleton &#123;&#10;&#9;private static class SingletonHolder &#123;&#10;&#9;&#9;private static final Singleton INSTANCE = new Singleton();&#10;&#9;&#125;&#10;&#10;&#9;private Singleton() &#123;&#125;&#10;&#10;&#9;public static Singleton getSingleton() &#123;&#10;&#9;&#9;return SingletonHolder.INSTANCE;&#10;&#9;&#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方式同样利用了Classloder的机制来保证线程安全性问题，当调用getSingleton()时，Java类加载器加载类SingletonHolder，而这一过程是由JVM来保证线程独占的。</p>
<h1 id="使用枚举实现懒加载">使用枚举实现懒加载</h1><p>《Effective Java》里所推荐的写法：<br><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象，但实现方式上比较独特，如果没有见过这种实现方式，看过这种代码可能会造成不必要的困惑。</p>
<h1 id="最后">最后</h1><p>总结一下，对于程序启动时就需要加载的单例类，直接使用非懒加载的方法即可，即简单易理解也不会出错。对于需要懒加载的单例类，可以考虑以上不同的解决方案，个人比较倾向于静态内部类的实现方式，理由在于多线程解决的方案过于复杂，枚举的实现又太新了，而对于静态内部类的实现，即使阅读代码的人不理解为什么这么做也不太会造成多大困扰。</p>

      </div>
      <footer class="article-footer">
        <a data-url="http://liyingjie.me/2015/07/09/Java-Singleton/" data-id="cibxn4mp3000014k1nnebgz3q" class="article-share-link">Share</a>
        
          <a href="http://liyingjie.me/2015/07/09/Java-Singleton/#comments" class="article-comment-link">Comments</a>
        
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

      </footer>
    </div>
  </article>
  
    <section id="comments">
      <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
      </div>
    </section>
  

            </div>
          </section>
        </div>
      </div>
    </div>
    <footer id="footer">
  
  <div class="container">
    <div class="container-inner">
      <a id="back-to-top" href="javascript:;"><i class="icon" id="icon-angle-up"></i></a>
      <div class="credit">
        <h1 class="logo-wrap">
          <a href="/" class="logo"></a>
        </h1>
        <p>&copy; 2015 liyingjie</p>
        <p>Powered by <a href="//hexo.io/" target="_blank">Hexo</a>. Theme by <a href="//github.com/ppoffice" target="_blank">PPOffice</a></p>
      </div>
    </div>
  </div>
</footer>
    
<script>
  var disqus_shortname = 'leesudo';
  
  var disqus_url = 'http://liyingjie.me/2015/07/09/Java-Singleton/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>



  <script src="http://code.jquery.com/jquery-2.1.3.min.js"></script>



  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>



  <script src="/scrollLoading/jquery.scrollLoading.js" type="text/javascript"></script>
  <script src="/scrollLoading/main.js" type="text/javascript"></script>


<script src="/js/html-patch.js" type="text/javascript"></script>
<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>
